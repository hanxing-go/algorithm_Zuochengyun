## 图的存储方式
1. 邻接表
2. 邻接矩阵

### 图的宽度优先遍历
1. 利用队列实现
2. 从源节点开始一次按照宽度进队列，然后弹出
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
4. 直到队列边空

### 图的广度优先遍历
1. 利用栈实现
2. 从源节点开始把节点按照深度放入栈，然后弹出
3. 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈
4. 直到栈边空


### 拓扑排序问题
1. 先找入度为0的点
2. 将这个点以及他产生的影响"其实就是边"删除
3. 重复第一步


### 方法论
如何表达图？生成图？

用自己最喜欢的图的表达方式，实现所有算法。

**经常使用的一些结构**
- 第一种
 ```java

  class GNode {
    public int value;   //值
    public int in;  // 入度
    public int out; // 出度
    public ArrayList<Node> nexts;    //直接邻居
    public ArrayList<Edge> edges;   //这个点拥有的边

    public GNode(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
  }

  class Edge {
    public int weight;
    public Node from;
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
  }

 ```

 如果碰到传递的是矩阵，那么可以用如下接口函数来进行变换：
 ```java
     //接口函数
    public static Graph creatGraph(Integer[][] matrix) {
        Graph graph = new Graph();
        for (int i = 0; i < matrix.length; i++) {
            Integer from = matrix[i][0];
            Integer to = matrix[i][1];
            Integer weight = matrix[i][2];

            if (!graph.nodes.containsKey(from)) {
                graph.nodes.put(from, new GNode(from));
            }
            if (!graph.nodes.containsKey(to)) {
                graph.nodes.put(to, new GNode(to));
            }

            GNode fromNode = graph.nodes.get(from);
            GNode toNode = graph.nodes.get(to);
            Edge newEdge = new Edge(weight, fromNode, toNode);
            fromNode.nexts.add(toNode);
            fromNode.out++;
            toNode.in++;
            fromNode.edges.add(newEdge);
            graph.edges.add(newEdge);
        }

        return graph;
    }
 ```